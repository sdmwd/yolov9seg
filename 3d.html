<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Transformation de Points avec mathjs</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjs/10.0.0/math.min.js"></script>
</head>
<body>
    <h1>Transformation de Points avec mathjs</h1>
    <pre id="output"></pre>

    <script>
        // Calculer le barycentre d'un ensemble de points
        function calculerBarycentre(points) {
            const sum = points.reduce((acc, point) => math.add(acc, point), math.zeros(points[0].length));
            return math.divide(sum, points.length);
        }

        // Algorithme de Kabsch pour trouver la matrice de rotation optimale
        function algorithmeDeKabsch(origines, destinations) {
            const H = math.multiply(math.transpose(origines), destinations);
            const { U, S, V } = math.svd(H);
            let R = math.multiply(V, math.transpose(U));
            
            // Assurer une rotation propre (det(R) doit être 1, pas -1)
            if (math.det(R) < 0) {
                V.subset(math.index([V.size()[0] - 1], math.range(0, V.size()[1])), math.multiply(V.subset(math.index([V.size()[0] - 1], math.range(0, V.size()[1]))), -1));
                R = math.multiply(V, math.transpose(U));
            }
            
            return R;
        }

        // Calculer le facteur de mise à l'échelle entre les deux ensembles de points
        function calculerFacteurEchelle(origines, destinations) {
            const distancesOrigines = math.norm(math.subtract(origines[1], origines[0]));
            const distancesDestinations = math.norm(math.subtract(destinations[1], destinations[0]));
            const facteurEchelle = distancesDestinations / distancesOrigines;
            return facteurEchelle;
        }

        // Trouver la matrice de transformation qui mappe l'ensemble Origines sur l'ensemble Destinations
        function trouverMatriceDeTransformation(origines, destinations) {
            const barycentreOrigines = calculerBarycentre(origines);
            const barycentreDestinations = calculerBarycentre(destinations);

            const originesTranslate = origines.map(point => math.subtract(point, barycentreOrigines));
            const destinationsTranslate = destinations.map(point => math.subtract(point, barycentreDestinations));

            const R = algorithmeDeKabsch(originesTranslate, destinationsTranslate);
            const facteurEchelle = calculerFacteurEchelle(originesTranslate, destinationsTranslate);

            const T = math.subtract(barycentreDestinations, math.multiply(facteurEchelle, math.multiply(R, barycentreOrigines)));

            const matriceDeTransformation = math.concat(math.multiply(facteurEchelle, R), math.reshape(T, [3, 1]));

            return matriceDeTransformation;
        }

        // Transformer un point en utilisant la matrice de transformation incluant la mise à l'échelle
        function transformerPoint(point, matriceDeTransformation) {
            const pointTransforme = math.add(math.multiply(matriceDeTransformation.subset(math.index(math.range(0, 3), math.range(0, 3))), point), matriceDeTransformation.subset(math.index(math.range(0, 3), 3)));
            return pointTransforme;
        }

        // Exemple d'utilisation
        const origines = [[1, 2, 3], [4, 5, 6], [7, 8, 9]];
        const destinations = [[2, 3, 4], [8, 9, 10], [14, 15, 16]];

        const matriceDeTransformation = trouverMatriceDeTransformation(origines, destinations);
        console.log("Matrice de transformation (3x4):\n", matriceDeTransformation.toString());

        const outputElement = document.getElementById('output');
        outputElement.textContent = `Matrice de transformation (3x4):\n${matriceDeTransformation.toString()}\n`;

        const pointOrigine = [1, 2, 3];
        const pointDestination = transformerPoint(pointOrigine, matriceDeTransformation);
        console.log("Point origine:", pointOrigine);
        console.log("Point transformé:", pointDestination.toString());

        outputElement.textContent += `\nPoint origine: ${pointOrigine}\nPoint transformé: ${pointDestination.toString()}\n`;
    </script>
</body>
</html>
